/** filepath: start.sh **/
#!/usr/bin/env bash

# Validate execution shell
if [ -z "$BASH_VERSION" ] && [ -z "$ZSH_VERSION" ]; then
    echo "Error: This script requires Bash or Zsh shell."
    echo "On Windows: Use Git Bash (https://gitforwindows.org)"
    exit 1
fi

# Error handling
error() {
    echo "Error: $1"
    echo "Quick fix:"
    echo "1. Install Node.js from https://nodejs.org"
    echo "2. Add Node.js to system PATH"
    exit 1
}

# Early dependency check
check_deps() {
    command -v node >/dev/null || error "Node.js not found"
    command -v npm >/dev/null || error "npm not found"
    
    if ! command -v http-server >/dev/null; then
        echo "Installing http-server..."
        npm install -g http-server || error "Install http-server failed"
    fi
}

# Initial checks
check_deps

# Configuration
STATION1_PORT=8764
STATION2_PORT=8765
EDITOR_PORT=8766
export BACKEND_PORT=3001
SERVER_PATH="server/index.js"

# Windows path conversion
win_path() {
    if [[ "$OSTYPE" == "msys"* ]]; then
        cygpath -w "$1"
    else
        echo "$1"
    fi
}

# Server management
start_server() {
    local name=$1 dir=$2 port=$3
    echo "Starting $name on port $port"
    http-server "$(win_path "$dir")" -p "$port" --silent &
    SERVER_PIDS+=($!)
}

# Cleanup
cleanup() {
    echo "Stopping all servers..."
    for pid in "${SERVER_PIDS[@]}"; do
        kill $pid 2>/dev/null
    done
    exit 0
}

# Main execution
trap cleanup SIGINT

# Database setup
if [ -f "server/package.json" ]; then
    echo "Installing DB dependencies..."
    (cd "$(win_path "server")" && npm install) || error "DB setup failed"
fi

# Service initialization
declare -a SERVER_PIDS=()

if [ -f "$SERVER_PATH" ]; then
    echo "Starting DB server..."
    node "$(win_path "$SERVER_PATH")" &
    SERVER_PIDS+=($!)
fi

start_server "Station 1" "station1" $STATION1_PORT
start_server "Station 2" "station2" $STATION2_PORT
start_server "Editor" editor $EDITOR_PORT

# Browser launch
(
    sleep 2
    if [[ "$OSTYPE" == "msys"* ]]; then
        cmd.exe /C start "http://localhost:$STATION1_PORT"
        cmd.exe /C start "http://localhost:$STATION2_PORT"
        cmd.exe /C start "http://localhost:$EDITOR_PORT"
    else
        open "http://localhost:$STATION1_PORT"
        open "http://localhost:$STATION2_PORT"
        open "http://localhost:$EDITOR_PORT"
    fi
) &

echo "Services running. Press Ctrl+C to stop"
wait
/** filepath: station1/index.html **/
/** filepath: server/index.js **/
const express = require("express");
const axios = require("axios");
const cors = require("cors");
const { Low, JSONFile } = require("lowdb");

const app = express();
const port = process.env.BACKEND_PORT || 3001; // Using logical OR for fallback

// Initialize lowdb with a JSON file adapter
const adapter = new JSONFile("./data.json");
const db = new Low(adapter);

// Initialize the database with an empty object if no data exists.
async function initDB() {
    await db.read();
    if (!db.data) {
        db.data = {}; // set default data
        await db.write();
    }
}
initDB();

if (!process.env.DASHSCOPE_API_KEY) {
    console.error(
        "Can't find LLM API key. If you are using bash or zsh, run `export DASHSCOPE_API_KEY=xxxxx`; if you are using Powershell/Command Prompt, run `set DASHSCOPE_API_KEY=xxxxxx`"
    );
}

// Enable CORS for all routes and parse incoming JSON bodies
app.use(cors());
app.use(express.json());

// ---------------------------
// Database Endpoints using lowdb
// ---------------------------

// GET endpoint to retrieve stored data
app.get("/data", async (req, res) => {
    await db.read();
    res.json(db.data);
});

// POST endpoint to update the stored data
app.post("/data", async (req, res) => {
    db.data = req.body;
    await db.write();
    res.json({ status: "success" });
});

// ---------------------------
// AI Proxy Endpoint
// ---------------------------
app.post("/ai", async (req, res) => {
    const { message } = req.body;

    try {
        // Use your environment variable for the API key
        const apiKey = process.env.DASHSCOPE_API_KEY;

        const response = await axios.post(
            "https://dashscope-intl.aliyuncs.com/compatible-mode/v1/chat/completions",
            {
                model: "qwen-turbo",
                messages: [
                    { role: "system", content: "You are a helpful assistant." },
                    { role: "user", content: message },
                ],
            },
            {
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`,
                },
            }
        );

        const reply =
            response.data?.choices &&
            response.data.choices[0].message?.content ||
            "No reply received";
        res.json({ reply });
    } catch (error) {
        console.error("Error calling AI API:", error.message);
        res.json({ reply: "Simulated response: I am the AI, but an error occurred." });
    }
});

// Start the server
app.listen(port, () => {
    console.log(`DB/AI server running at http://localhost:${port}`);
});
/** filepath: station2/index.html **/
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Station 2 - Twine App</title>
    <link rel="stylesheet" type="text/css" href="sugarcube.css" />
  </head>
  <body>
    <div id="story">
      <!-- Basic Twine story data for Station 2 -->
      <tw-storydata
        name="Station2Story"
        startnode="1"
        creator="Twine"
        creator-version="2.x"
        ifid="example-id-2"
      >
        <tw-passagedata pid="1" name="Start">
          Welcome to Station 2. Click below to request your symbolic map from
          the AI.<br />
          <button onclick="callAI()">Generate Map</button>
          <div id="ai-response" style="margin-top: 1em; color: green"></div>
        </tw-passagedata>
      </tw-storydata>
    </div>
    <script>
      function callAI() {
        fetch("http://localhost:3000/ai", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ message: "Generate my map" }),
        })
          .then((response) => response.json())
          .then((data) => {
            document.getElementById("ai-response").innerHTML =
              data.reply || "No reply";
          })
          .catch((err) => {
            console.error("Error:", err);
            document.getElementById("ai-response").innerHTML =
              "Error contacting AI.";
          });
      }
    </script>
  </body>
</html>
/** filepath: editor/index.html **/
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Vue RWS Author Tool - Linear Block Builder</title>
    <style>
      /* ---------------------------------------------------
         CSS Custom Properties (Variables)
         --------------------------------------------------- */
      :root {
        /* --- Colors (Grouped by their usage) --- */
        --color-bg-body: #f2f2f2;
        --color-bg-toolbar: #e5e5e5;
        --color-bg-scene: #c7bcbc;
        --color-bg-block: #f1f1f1;
        --color-bg-narrative: #fff;
        --font-size-narrative: 20px;
        --color-text-body: #0000005b;
        --color-text-narrative: #000;
        --color-border-toolbar: #ffffff;
        --color-border-block: rgba(0, 0, 0, 0.364);
        --color-border-input: #ccc;
        --color-bg-button-hover: #0000005b;
        --color-text-other: #888;

        /* --- Typography --- */
        --font-family-default: monospace;
        --font-family-narrative: serif;
        --font-size-base: 14px;
        --font-size-toolbar: 14px;
        --font-size-button: 14px;
        --line-height-base: 1.5;

        /* --- Spacing & Sizing --- */
        --padding-body: 0;
        --padding-toolbar: 10px;
        --padding-scene: 15px;
        --padding-block: 10px;
        --margin-toolbar-button: 5px;
        --margin-block: 15px;
        --margin-dynamic-row: 5px;
        --margin-static-option: 5px;
        --gap-dynamic-row: 1rem;
        --margin-scene-top: 70px;
        --margin-scene-bottom: 20px;

        /* --- Borders --- */
        --border-toolbar: 1px solid var(--color-border-toolbar);
        --border-block: 1px solid var(--color-border-block);
        --border-dashed: 1px dashed var(--color-border-toolbar);

        /* --- Layout --- */
        --z-index-toolbar: 1000;
      }

      /* ---------------------------------------------------
         Global Styles and Element Resets
         --------------------------------------------------- */
      body {
        margin: var(--padding-body);
        padding: var(--padding-body);
        font-family: var(--font-family-default);
        font-size: var(--font-size-base);
        line-height: var(--line-height-base);
        background: var(--color-bg-body);
        color: var(--color-text-body);
      }

      textarea {
        resize: none;
        width: 100%;
        box-sizing: border-box;
        overflow: hidden;
      }

      /* ---------------------------------------------------
         Toolbar Styles
         --------------------------------------------------- */
      .toolbar {
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: var(--color-bg-toolbar);
        border-bottom: var(--border-toolbar);
        padding: var(--padding-toolbar);
        z-index: var(--z-index-toolbar);
      }

      .toolbar button {
        margin: var(--margin-toolbar-button);
        padding: 10px 15px;
        font-size: var(--font-size-button);
        cursor: pointer;
        border: none;
        background: var(--color-bg-toolbar);
      }

      .toolbar button:hover {
        background: var(--color-bg-button-hover);
      }

      /* ---------------------------------------------------
         Scene Wrapper & Autosave Header
         --------------------------------------------------- */
      .scene-wrapper {
        margin: var(--margin-scene-top) auto var(--margin-scene-bottom);
        padding: var(--padding-scene);
        background: var(--color-bg-scene);
        display: flex;
        flex-direction: column;
      }

      .autosave-header {
        text-align: center;
        padding: 5px;
        margin-bottom: 10px;
        background: var(--color-bg-toolbar);
      }

      /* ---------------------------------------------------
         Grid Container for Blocks & Separating Lines
         --------------------------------------------------- */
      #contentContainer {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        gap: var(--margin-block);
        margin-bottom: 20px;
      }

      /* Each block has a minimum width of 400px and a bottom border as a divider. */
      .block {
        background: var(--color-bg-block);
        padding: var(--padding-block);
        display: flex;
        flex-direction: column;
        min-width: 400px;
        border-bottom: 1px solid #ccc;
      }

      /* ---------------------------------------------------
         Block Header, Index, and Controls using Flexbox
         --------------------------------------------------- */
      .block-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
      }

      .block-index {
        font-size: 10px;
        color: #333;
        padding: 2px 4px;
        border-radius: 2px;
      }

      .block-controls {
        display: flex;
        gap: 5px;
      }

      .block-controls button {
        background: var(--color-bg-toolbar);
        border: none;
        padding: 5px;
        cursor: pointer;
      }

      .block-controls button:hover {
        background: var(--color-bg-button-hover);
      }

      .block-body {
        margin-top: 5px;
      }

      .block-info {
        font-size: 8px;
      }

      /* ---------------------------------------------------
         Plain Block (Narrative Textarea)
         --------------------------------------------------- */
      .narrative-textarea {
        font-family: var(--font-family-narrative);
        background-color: var(--color-bg-narrative);
        color: var(--color-text-narrative);
        font-size: var(--font-size-narrative);
        padding: 10px;
        margin-top: 5px;
        border: 1px solid var(--color-border-input);
      }

      /* ---------------------------------------------------
         Dynamic Block Input Row
         --------------------------------------------------- */
      .dynamic-input-row {
        display: flex;
        gap: var(--gap-dynamic-row);
        margin-bottom: var(--margin-dynamic-row);
        flex-wrap: wrap;
      }

      .dynamic-input-row > div {
        flex: 1;
      }

      /* ---------------------------------------------------
         Static Option Block
         --------------------------------------------------- */
      .static-options-container {
        margin-top: 5px;
      }

      .static-options-container input {
        margin-bottom: var(--margin-static-option);
        padding: 5px;
        font-family: var(--font-family-narrative);
        font-size: var(--font-size-narrative);
        border: 1px solid var(--color-border-input);
      }

      /* ---------------------------------------------------
         Context Items (For Dynamic Blocks)
         --------------------------------------------------- */
      .context-list {
        margin-top: 5px;
      }

      .context-item {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 10px;
        margin-bottom: 5px;
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 4px;
      }

      .context-item select {
        flex: 1 1 auto;
        min-width: 200px;
      }

      .context-checkbox {
        display: flex;
        align-items: center;
        gap: 3px;
      }

      /* ---------------------------------------------------
         Special Styles for Specific Block Types
         --------------------------------------------------- */
      .block[data-block-type="scene-header"] {
        grid-column: 1 / -1;
        background-color: lightyellow;
      }
      .block[data-block-type="dynamic-option"],
      .block[data-block-type="dynamic-text"],
      .block[data-block-type="dynamic-word"] {
        background-color: #ffcccc;
      }
    </style>
  </head>
  <body>
    <!-- Dynamic Block Template (for Dynamic Option / Text / Word) -->
    <script type="text/x-template" id="dynamic-block-template">
      <div>
        <div class="dynamic-input-row">
          <div>
            Block Name:
            <input type="text" v-model="block.blockName" />
          </div>
          <div v-if="isOption">
            Option Count:
            <input type="number" v-model.number="block.optionCount" />
          </div>
          <div v-else-if="isText">
            Sentence Count:
            <input type="number" v-model.number="block.sentenceCount" />
          </div>
          <div v-else-if="isWord">
            Lexicon Category:
            <select v-model="block.lexiconCategory">
              <option value="noun">Noun</option>
              <option value="adverb">Adverb</option>
              <option value="adjective">Adjective</option>
            </select>
          </div>
        </div>
        <!-- Prompt Section (common to all dynamic blocks) -->
        <div style="margin-top: 5px; margin-bottom: 5px">
          Prompt:
          <br />
          <textarea
            v-model="block.prompt"
            v-auto-resize
            rows="2"
            placeholder="Enter prompt text..."
          ></textarea>
        </div>
        <!-- Unified Context Section -->
        <div style="margin-bottom: 5px; display: flex; align-items: center">
          Context:
          <button @click="emitAddContext" style="margin-left: 5px">+</button>
        </div>
        <div class="context-list">
          <div
            v-for="(ctx, ctxIndex) in block.context"
            :key="ctxIndex"
            class="context-item"
          >
            <select v-model="ctx.value">
              <option value="">-- none --</option>
              <option
                v-for="blockItem in parentContextBlocks"
                :key="blockItem.id"
                :value="blockItem.id"
              >
                <template v-if="blockItem.type === 'dynamic-option'">
                  {{ getIndex(blockItem) + 1 }} - {{ blockItem.blockName }} - [{{ blockItem.id }}]
                </template>
                <template v-else-if="blockItem.type === 'static'">
                  {{ getIndex(blockItem) + 1 }} - Static Option Block - [{{ blockItem.id }}]
                </template>
                <template v-else-if="blockItem.type === 'dynamic-text'">
                  {{ getIndex(blockItem) + 1 }} - {{ blockItem.blockName }} (Dynamic Text) - [{{ blockItem.id }}]
                </template>
                <template v-else-if="blockItem.type === 'dynamic-word'">
                  {{ getIndex(blockItem) + 1 }} - {{ blockItem.blockName }} (Dynamic Word) - [{{ blockItem.id }}]
                </template>
              </option>
            </select>
            <div class="context-checkbox">
              <input
                type="checkbox"
                v-model="ctx.includeAll"
                :id="'include-checkbox-' + block.id + '-' + ctxIndex"
              />
              <label :for="'include-checkbox-' + block.id + '-' + ctxIndex">
                Include all previous players response
              </label>
            </div>
            <button @click="emitRemoveContext(ctxIndex)">x</button>
          </div>
        </div>
      </div>
    </script>

    <div id="app">
      <!-- Toolbar -->
      <div class="toolbar">
        <button @click="addPlainBlock">+ Plain Block</button>
        <button @click="addStaticOptionBlock">+ Static Option</button>
        <button @click="addDynamicOptionBlock">+ Dynamic Option Block</button>
        <button @click="addDynamicTextBlock">+ Dynamic Text Block</button>
        <button @click="addDynamicWordBlock">+ Dynamic Word Block</button>
        <button @click="addSceneHeaderBlock">+ Scene Header Block</button>
        <button @click="playStory">[Play]</button>
        <button @click="exportJson">Export Project as JSON</button>
        <button @click="saveProject">Save Project</button>
      </div>

      <!-- Main Content Area -->
      <div class="scene-wrapper">
        <div class="autosave-header">autosaved: {{ autosaveTime }}</div>
        <!-- Content Container for Blocks -->
        <div id="contentContainer">
          <div
            v-for="(block, index) in blocks"
            :key="block.id"
            class="block"
            :data-block-type="block.type"
          >
            <div class="block-header">
              <div class="block-index">{{ index + 1 }}</div>
              <div class="block-controls">
                <button @click="moveBlockUp(index)">↑</button>
                <button @click="moveBlockDown(index)">↓</button>
                <button @click="removeBlock(index)">x</button>
              </div>
            </div>
            <div class="block-body">
              <!-- Plain Block -->
              <template v-if="block.type === 'plain'">
                <textarea
                  v-model="block.text"
                  class="narrative-textarea"
                  placeholder="Your narrative..."
                  v-auto-resize
                ></textarea>
              </template>

              <!-- Static Option Block -->
              <template v-if="block.type === 'static'">
                <label>Pre-Authored Options:</label>
                <div class="static-options-container">
                  <div v-for="(option, oIndex) in block.options" :key="oIndex">
                    <input
                      type="text"
                      v-model="block.options[oIndex]"
                      placeholder="Option"
                    />
                    <button @click="removeStaticOption(block, oIndex)">
                      x
                    </button>
                  </div>
                </div>
                <button
                  class="add-static-option-btn"
                  @click="addStaticOption(block)"
                  style="margin-top: 5px"
                >
                  Add Option
                </button>
              </template>

              <!-- Dynamic Blocks (Option, Text, Word) -->
              <template
                v-if="['dynamic-option','dynamic-text','dynamic-word'].includes(block.type)"
              >
                <dynamic-block
                  :block="block"
                  @add-context="addContext"
                  @remove-context="removeContext"
                ></dynamic-block>
              </template>

              <!-- Scene Header Block -->
              <template v-if="block.type === 'scene-header'">
                Title Name:
                <input
                  type="text"
                  v-model="block.titleName"
                  placeholder="Enter scene title"
                />
              </template>
            </div>
            <!-- Block Information at the Bottom -->
            <div class="block-info">
              {{ block.type }}
              <template v-if="block.id"> - UUID: {{ block.id }} </template>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Vue 3 via CDN -->
    <script src="https://unpkg.com/vue@3"></script>
    <script>
      const { createApp } = Vue;
      const app = createApp({
        data() {
          return {
            autosaveTime: "",
            blocks: [], // Array to hold block objects.
          };
        },
        computed: {
          // Available context blocks include dynamic-option, static, dynamic-text, and dynamic-word blocks.
          contextBlocks() {
            return this.blocks.filter((b) =>
              [
                "dynamic-option",
                "static",
                "dynamic-text",
                "dynamic-word",
              ].includes(b.type)
            );
          },
        },
        watch: {
          // Watch the blocks array (and nested properties) for any change.
          blocks: {
            handler(newVal, oldVal) {
              this.syncUI();
              this.debounceSaveProject();
            },
            deep: true,
          },
        },
        directives: {
          // Custom directive for auto-resizing textareas.
          autoResize: {
            mounted(el) {
              el.style.overflow = "hidden";
              const resize = () => {
                el.style.height = "auto";
                el.style.height = el.scrollHeight + "px";
              };
              resize();
              el.addEventListener("input", resize);
            },
            updated(el) {
              el.style.height = "auto";
              el.style.height = el.scrollHeight + "px";
            },
          },
        },
        methods: {
          debounceSaveProject() {
            clearTimeout(this._saveTimeout);
            this._saveTimeout = setTimeout(() => {
              this.saveProject();
            }, 500);
          },
          syncUI() {
            console.log("UI has been updated.");
          },
          updateAutosaveTime() {
            const now = new Date();
            this.autosaveTime =
              now.getFullYear() +
              "-" +
              (now.getMonth() + 1) +
              "-" +
              now.getDate() +
              " " +
              now.getHours() +
              ":" +
              now.getMinutes() +
              ":" +
              now.getSeconds();
          },
          generateUUID() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
              /[xy]/g,
              (c) => {
                const r = (Math.random() * 16) | 0;
                const v = c === "x" ? r : (r & 0x3) | 0x8;
                return v.toString(16);
              }
            );
          },
          addPlainBlock() {
            const id = this.generateUUID();
            this.blocks.push({ id, type: "plain", text: "Your narrative..." });
          },
          addStaticOptionBlock() {
            const id = this.generateUUID();
            this.blocks.push({ id, type: "static", options: [] });
          },
          addDynamicOptionBlock() {
            const id = this.generateUUID();
            this.blocks.push({
              id,
              type: "dynamic-option",
              blockName: "xxx",
              optionCount: 3,
              prompt: "",
              context: [],
            });
          },
          addDynamicTextBlock() {
            const id = this.generateUUID();
            this.blocks.push({
              id,
              type: "dynamic-text",
              blockName: "",
              sentenceCount: 1,
              prompt: "",
              context: [],
            });
          },
          addDynamicWordBlock() {
            const id = this.generateUUID();
            this.blocks.push({
              id,
              type: "dynamic-word",
              blockName: "",
              lexiconCategory: "noun",
              prompt: "",
              context: [],
            });
          },
          addSceneHeaderBlock() {
            const id = this.generateUUID();
            this.blocks.push({ id, type: "scene-header", titleName: "" });
          },
          removeBlock(index) {
            this.blocks.splice(index, 1);
          },
          moveBlockUp(index) {
            if (index > 0) {
              const movingBlock = this.blocks.splice(index, 1)[0];
              this.blocks.splice(index - 1, 0, movingBlock);
            }
          },
          moveBlockDown(index) {
            if (index < this.blocks.length - 1) {
              const movingBlock = this.blocks.splice(index, 1)[0];
              this.blocks.splice(index + 1, 0, movingBlock);
            }
          },
          addStaticOption(block) {
            block.options.push("");
          },
          removeStaticOption(block, index) {
            block.options.splice(index, 1);
          },
          // Unified context methods for dynamic blocks.
          addContext(block) {
            block.context.push({ value: "", includeAll: false });
          },
          removeContext(block, ctxIndex) {
            block.context.splice(ctxIndex, 1);
          },
          playStory() {
            this.updateAutosaveTime();
            const compiledStory = {
              autosave: this.autosaveTime,
              blocks: this.blocks.map((block) => {
                if (block.type === "plain") {
                  return { type: "plain", text: block.text };
                } else if (block.type === "static") {
                  return {
                    type: "static",
                    uuid: block.id,
                    options: block.options.filter((opt) => opt.trim() !== ""),
                  };
                } else if (block.type === "dynamic-option") {
                  return {
                    type: "dynamic-option",
                    uuid: block.id,
                    blockName: block.blockName,
                    optionCount: block.optionCount,
                    prompt: block.prompt.trim(),
                    context: block.context,
                  };
                } else if (block.type === "dynamic-text") {
                  return {
                    type: "dynamic-text",
                    uuid: block.id,
                    blockName: block.blockName,
                    sentenceCount: block.sentenceCount,
                    prompt: block.prompt.trim(),
                    context: block.context,
                  };
                } else if (block.type === "dynamic-word") {
                  return {
                    type: "dynamic-word",
                    uuid: block.id,
                    blockName: block.blockName,
                    lexiconCategory: block.lexiconCategory,
                    prompt: block.prompt.trim(),
                    context: block.context,
                  };
                } else if (block.type === "scene-header") {
                  return {
                    type: "scene-header",
                    titleName: block.titleName.trim(),
                  };
                }
                return {};
              }),
            };
            console.log("Compiled Story:", compiledStory);
            alert("Story compiled! (Check console for details.)");
          },
          exportJson() {
            this.updateAutosaveTime();
            const project = {
              autosave: this.autosaveTime,
              blocks: this.blocks.map((block) => {
                if (block.type === "plain") {
                  return { type: "plain", text: block.text };
                } else if (block.type === "static") {
                  return {
                    type: "static",
                    uuid: block.id,
                    options: block.options.filter((opt) => opt.trim() !== ""),
                  };
                } else if (block.type === "dynamic-option") {
                  return {
                    type: "dynamic-option",
                    uuid: block.id,
                    blockName: block.blockName,
                    optionCount: block.optionCount,
                    prompt: block.prompt.trim(),
                    context: block.context,
                  };
                } else if (block.type === "dynamic-text") {
                  return {
                    type: "dynamic-text",
                    uuid: block.id,
                    blockName: block.blockName,
                    sentenceCount: block.sentenceCount,
                    prompt: block.prompt.trim(),
                    context: block.context,
                  };
                } else if (block.type === "dynamic-word") {
                  return {
                    type: "dynamic-word",
                    uuid: block.id,
                    blockName: block.blockName,
                    lexiconCategory: block.lexiconCategory,
                    prompt: block.prompt.trim(),
                    context: block.context,
                  };
                } else if (block.type === "scene-header") {
                  return {
                    type: "scene-header",
                    titleName: block.titleName.trim(),
                  };
                }
                return {};
              }),
            };
            const jsonString = JSON.stringify(project, null, 2);
            const blob = new Blob([jsonString], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "project_export.json";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          },
          saveProject() {
            // Store the current scroll position to prevent auto-scrolling.
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;
            this.updateAutosaveTime();
            const project = {
              autosave: this.autosaveTime,
              blocks: this.blocks,
            };
            localStorage.setItem("vueRWSProject", JSON.stringify(project));
            console.log("saved!");
            this.$nextTick(() => {
              window.scrollTo(scrollX, scrollY);
            });
          },
        },
        mounted() {
          const savedData = localStorage.getItem("vueRWSProject");
          if (savedData) {
            try {
              const parsedData = JSON.parse(savedData);
              this.autosaveTime = parsedData.autosave || "";
              this.blocks = parsedData.blocks || [];
            } catch (error) {
              console.error("Error parsing saved project", error);
            }
          }
          this.updateAutosaveTime();
        },
      });

      // Register the dynamic-block component.
      app.component("dynamic-block", {
        template: "#dynamic-block-template",
        props: ["block"],
        computed: {
          isOption() {
            return this.block.type === "dynamic-option";
          },
          isText() {
            return this.block.type === "dynamic-text";
          },
          isWord() {
            return this.block.type === "dynamic-word";
          },
          parentContextBlocks() {
            // Access parent's contextBlocks.
            return this.$parent.contextBlocks;
          },
        },
        methods: {
          emitAddContext() {
            this.$emit("add-context", this.block);
          },
          emitRemoveContext(ctxIndex) {
            this.$emit("remove-context", this.block, ctxIndex);
          },
          getIndex(blockItem) {
            return this.$parent.blocks.indexOf(blockItem);
          },
        },
      });

      app.mount("#app");
    </script>
  </body>
</html>
/** filepath: editor/playable/index.html **/
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Playable Story</title>
    <link rel="stylesheet" href="playable_style.css" />
  </head>
  <body>
    <!-- Container for compiled passages -->
    <div id="passageContainer">
      <!-- The compiler.js script will inject the playable content here -->
    </div>
    <script src="compiler.js"></script>
  </body>
</html>
/** filepath: editor/playable/compiler.js **/
(function () {
    // Sample project JSON.
    // In production, you would load or pass in the exported JSON instead.
    var project = {
        autosave: "2025-02-24 10:00:00",
        blocks: [
            { type: "plain", text: "Welcome to our interactive story!" },
            { type: "static", options: ["Option A", "Option B"] },
            {
                type: "dynamic-option",
                blockName: "Dynamic Options",
                optionCount: 3,
                prompt: "Choose one dynamically",
                context: []
            },
            { type: "scene-header", titleName: "Scene Break" },
            { type: "plain", text: "This is the second page." },
            {
                type: "dynamic-text",
                blockName: "Dynamic Text",
                sentenceCount: 2,
                prompt: "Generate text here",
                context: []
            },
            {
                type: "dynamic-word",
                blockName: "Dynamic Word",
                lexiconCategory: "noun",
                prompt: "Give me a noun",
                context: []
            }
        ]
    };

    /**
     * Compiles the project JSON into a string containing HTML passages.
     * Blocks between scene-header blocks are grouped as a single passage.
     */
    function compilePlayableContent(proj) {
        var passages = [];
        var currentPassage = "";

        proj.blocks.forEach(function (block) {
            // Scene headers are used only as passage dividers.
            if (block.type === "scene-header") {
                if (currentPassage.trim() !== "") {
                    passages.push(currentPassage);
                }
                currentPassage = ""; // Reset passage content.
                return;
            }
            if (block.type === "plain") {
                currentPassage += `<span class="plain">${block.text}</span>`;
            } else if (block.type === "static") {
                var optionsHtml = "";
                block.options.forEach(function (option) {
                    if (option.trim() !== "") {
                        optionsHtml += `<span class="static-option" onclick="selectOption(this)">${option}</span>`;
                    }
                });
                currentPassage += `<span class="static-options">${optionsHtml}</span>`;
            } else if (block.type === "dynamic-option") {
                // Render dynamic option block using a data attribute.
                currentPassage += `<span class="dynamic-options" data-block='${JSON.stringify(
                    block
                )}'>Loading dynamic options...</span>`;
            } else if (block.type === "dynamic-text") {
                currentPassage += `<span class="dynamic-text-result" data-block='${JSON.stringify(
                    block
                )}'>Loading dynamic text...</span>`;
            } else if (block.type === "dynamic-word") {
                currentPassage += `<span class="dynamic-word-result" data-block='${JSON.stringify(
                    block
                )}'>Loading dynamic word...</span>`;
            }
        });
        // Push the final passage if it has content.
        if (currentPassage.trim() !== "") {
            passages.push(currentPassage);
        }

        // Build the full HTML for passages.
        // Use a single class attribute per passage.
        var passagesHtml = "";
        for (var i = 0; i < passages.length; i++) {
            passagesHtml += `<div class="passage ${i === 0 ? "active" : ""}" id="passage-${i}">
          ${passages[i]}
          ${i < passages.length - 1 ? `<br/><a href="#" class="next-link" onclick="goToNextPassage(${i})">Proceed</a>` : ""}
        </div>`;
        }
        return passagesHtml;
    }

    // Renders the compiled passages into the container.
    function renderPlayableContent() {
        var container = document.getElementById("passageContainer");
        container.innerHTML = compilePlayableContent(project);
        processDynamicBlocks();
    }

    // Passage navigation: hide current, show next.
    window.goToNextPassage = function (currentIndex) {
        var current = document.getElementById("passage-" + currentIndex);
        var next = document.getElementById("passage-" + (currentIndex + 1));
        if (current && next) {
            current.classList.remove("active");
            next.classList.add("active");
        }
    };

    // Option selection: record selection and fade out unselected options.
    window.selectOption = function (element) {
        var container = element.parentElement;
        var options = container.getElementsByClassName("static-option");
        for (var i = 0; i < options.length; i++) {
            options[i].classList.add("faded");
        }
        element.classList.remove("faded");
        element.classList.add("selected");
        // Optionally record the selection here.
    };

    /**
     * Process dynamic blocks.
     * In a real scenario, you would send block data via AJAX/fetch to your backend routes
     * (for example, '/api/dynamic-option', '/api/dynamic-text', etc.)
     * and then update the block content with the backend response.
     * Here, we simulate the responses.
     */
    function processDynamicBlocks() {
        // Process Dynamic Option blocks.
        var dynamicOptions = document.getElementsByClassName("dynamic-options");
        for (var i = 0; i < dynamicOptions.length; i++) {
            // Simulated backend response.
            dynamicOptions[i].innerHTML =
                "<ul>" +
                "<li onclick='selectOption(this)'>Dynamic Option 1</li>" +
                "<li onclick='selectOption(this)'>Dynamic Option 2</li>" +
                "</ul>";
        }
        // Process Dynamic Text blocks.
        var dynamicText = document.getElementsByClassName("dynamic-text-result");
        for (var i = 0; i < dynamicText.length; i++) {
            dynamicText[i].innerHTML =
                "This is the dynamic text generated by our backend.";
        }
        // Process Dynamic Word blocks.
        var dynamicWord = document.getElementsByClassName("dynamic-word-result");
        for (var i = 0; i < dynamicWord.length; i++) {
            dynamicWord[i].innerHTML =
                '<span class="dynamic-word-result">DynamicWord</span>';
        }
    }

    // Use DOMContentLoaded to initialize the playable content.
    document.addEventListener("DOMContentLoaded", renderPlayableContent);
})();
/** filepath: editor/playable/playable.style.css **/
/* Basic styling for the playable page */
body {
    font-family: sans-serif;
    margin: 0;
    padding: 20px;
}

.passage {
    display: none;
    padding: 20px;
}

.passage.active {
    display: block;
}

/* Plain block styling */
span.plain {
    display: block;
    margin-bottom: 10px;
}

/* Static options: each option appears as a clickable line */
.static-options span.static-option {
    display: block;
    padding: 5px;
    margin: 5px 0;
    cursor: pointer;
    border: 1px solid #ccc;
}

.static-option.selected {
    background: #ddd;
}

.static-option.faded {
    opacity: 0.3;
}

/* Dynamic blocks wrappers for later styling */
span.dynamic-options,
span.dynamic-text-result,
span.dynamic-word-result {
    display: block;
    margin: 10px 0;
    font-style: italic;
}

/* Link styling for the navigation "Proceed" link */
a.next-link {
    display: block;
    margin-top: 20px;
    font-weight: bold;
    text-decoration: none;
    color: blue;
}
