<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Vue RWS Author Tool - Linear Block Builder</title>
    <link rel="stylesheet" href="editor.css" />
  </head>
  <body>
    <!-- Dynamic Block Template (for Dynamic Option / Text / Word) -->
    <script type="text/x-template" id="dynamic-block-template">
      <div>
        <div class="dynamic-input-row">
          <div>
            Block Name:
            <input type="text" v-model="block.blockName" />
          </div>
          <div v-if="isOption">
            Option Count:
            <input type="number" v-model.number="block.optionCount" />
          </div>
          <div v-else-if="isText">
            Sentence Count:
            <input type="number" v-model.number="block.sentenceCount" />
          </div>
          <div v-else-if="isWord">
            Lexicon Category:
            <select v-model="block.lexiconCategory">
              <option value="noun">Noun</option>
              <option value="adverb">Adverb</option>
              <option value="adjective">Adjective</option>
            </select>
          </div>
        </div>
        <!-- Prompt Section (common to all dynamic blocks) -->
        <div style="margin-top: 5px; margin-bottom: 5px">
          Prompt:
          <br />
          <textarea
            v-model="block.prompt"
            class="scrollable-textarea"
            rows="8"
            placeholder="Enter prompt text..."
            style="overflow-y: auto; resize: vertical; height: 120px;"
          ></textarea>
        </div>
        <!-- Unified Context Section -->
        <div style="margin-bottom: 5px; display: flex; align-items: center">
          Context:
          <button @click="emitAddContext" style="margin-left: 5px">+</button>
        </div>
        <div class="context-list">
          <div
            v-for="(ctx, ctxIndex) in block.context"
            :key="ctxIndex"
            class="context-item"
          >
            <select v-model="ctx.value">
              <option value="">-- none --</option>
              <option
                v-for="blockItem in parentContextBlocks"
                :key="blockItem.id"
                :value="blockItem.id"
              >
                <template v-if="blockItem.type === 'dynamic-option'">
                  {{ getIndex(blockItem) + 1 }} - {{ blockItem.blockName }} - [{{ blockItem.id }}]
                </template>
                <template v-else-if="blockItem.type === 'static'">
                  {{ getIndex(blockItem) + 1 }} - Static Option Block - [{{ blockItem.id }}]
                </template>
                <template v-else-if="blockItem.type === 'dynamic-text'">
                  {{ getIndex(blockItem) + 1 }} - {{ blockItem.blockName }} (Dynamic Text) - [{{ blockItem.id }}]
                </template>
                <template v-else-if="blockItem.type === 'dynamic-word'">
                  {{ getIndex(blockItem) + 1 }} - {{ blockItem.blockName }} (Dynamic Word) - [{{ blockItem.id }}]
                </template>
              </option>
            </select>
            <div class="context-checkbox">
              <input
                type="checkbox"
                v-model="ctx.includeAll"
                :id="'include-checkbox-' + block.id + '-' + ctxIndex"
              />
              <label :for="'include-checkbox-' + block.id + '-' + ctxIndex">
                Include all previous players response
              </label>
            </div>
            <button @click="emitRemoveContext(ctxIndex)">x</button>
          </div>
        </div>
      </div>
    </script>

    <!-- Hidden file input for JSON import -->
    <input
      type="file"
      id="jsonFileInput"
      accept=".json"
      style="display: none"
    />

    <div id="app">
      <!-- Toolbar -->
      <div class="toolbar">
        <button @click="addPlainBlock">+ Plain Block</button>
        <button @click="addStaticOptionBlock">+ Static Option</button>
        <button @click="addDynamicOptionBlock">+ Dynamic Option Block</button>
        <button @click="addDynamicTextBlock">+ Dynamic Text Block</button>
        <button @click="addDynamicWordBlock">+ Dynamic Word Block</button>
        <button @click="addSceneHeaderBlock">+ Scene Header Block</button>
        <button @click="playStory">Play</button>
        <button @click="exportJson">Export Project as JSON</button>
        <button @click="importJson">Import Project</button>
        <!-- Save Project button now triggers saving to the server -->
        <button @click="saveProject">Save Project</button>
      </div>

      <!-- Main Content Area -->
      <div class="scene-wrapper">
        <div class="autosave-header">autosaved: {{ autosaveTime }}</div>
        <!-- Content Container for Blocks -->
        <div id="contentContainer">
          <div
            v-for="(block, index) in blocks"
            :key="block.id"
            class="block"
            :data-block-type="block.type"
          >
            <div class="block-header">
              <div class="block-index">{{ index + 1 }}</div>
              <div class="block-controls">
                <button @click="moveBlockUp(index)">↑</button>
                <button @click="moveBlockDown(index)">↓</button>
                <button @click="removeBlock(index)">x</button>
              </div>
            </div>
            <div class="block-body">
              <!-- Plain Block -->
              <template v-if="block.type === 'plain'">
                <textarea
                  v-model="block.text"
                  class="narrative-textarea"
                  placeholder="Your narrative..."
                  v-auto-resize
                ></textarea>
              </template>

              <!-- Static Option Block -->
              <template v-if="block.type === 'static'">
                <label>Pre-Authored Options:</label>
                <div class="static-options-container">
                  <div v-for="(option, oIndex) in block.options" :key="oIndex">
                    <input
                      type="text"
                      v-model="block.options[oIndex]"
                      placeholder="Option"
                    />
                    <button @click="removeStaticOption(block, oIndex)">
                      x
                    </button>
                  </div>
                </div>
                <button
                  class="add-static-option-btn"
                  @click="addStaticOption(block)"
                  style="margin-top: 5px"
                >
                  Add Option
                </button>
              </template>

              <!-- Dynamic Blocks (Option, Text, Word) -->
              <template
                v-if="['dynamic-option','dynamic-text','dynamic-word'].includes(block.type)"
              >
                <dynamic-block
                  :block="block"
                  @add-context="addContext"
                  @remove-context="removeContext"
                ></dynamic-block>
              </template>

              <!-- Scene Header Block -->
              <template v-if="block.type === 'scene-header'">
                Scene ID: {{ block.sceneId }}<br />
                Title Name:
                <input
                  type="text"
                  v-model="block.titleName"
                  placeholder="Enter scene title"
                />
              </template>
            </div>
            <!-- Block Information at the Bottom -->
            <div class="block-info">
              {{ block.type }}
              <template v-if="block.id"> - UUID: {{ block.id }} </template>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Vue 3 via CDN -->
    <!-- TODO: use local lib  -->
    <script src="https://unpkg.com/vue@3"></script>
    <script>
      const { createApp } = Vue;
      const app = createApp({
        data() {
          return {
            autosaveTime: "",
            blocks: [],
          };
        },
        computed: {
          contextBlocks() {
            return this.blocks.filter((b) =>
              [
                "dynamic-option",
                "static",
                "dynamic-text",
                "dynamic-word",
              ].includes(b.type)
            );
          },
          // Compute the target station from the URL.
          station() {
            // Assumes the editor is loaded under /editor/station1 or /editor/station2.
            if (window.location.pathname.includes("station2")) {
              return "station2";
            }
            return "station1";
          },
        },
        watch: {
          blocks: {
            handler(newVal, oldVal) {
              this.syncUI();
              this.updateSceneIds();
              // Auto-save changes to localStorage
              this.debounceSaveProject();
            },
            deep: true,
          },
        },
        directives: {
          autoResize: {
            mounted(el) {
              // Don't auto-resize if it's a scrollable textarea
              if (el.classList.contains("scrollable-textarea")) {
                return;
              }

              el.style.overflow = "hidden";
              const resize = () => {
                el.style.height = "auto";
                el.style.height = el.scrollHeight + "px";
              };
              resize();
              el.addEventListener("input", resize);
            },
            updated(el) {
              // Don't auto-resize if it's a scrollable textarea
              if (el.classList.contains("scrollable-textarea")) {
                return;
              }

              el.style.height = "auto";
              el.style.height = el.scrollHeight + "px";
            },
          },
        },
        methods: {
          debounceSaveProject() {
            clearTimeout(this._saveTimeout);
            this._saveTimeout = setTimeout(() => {
              this.autoSaveProject();
            }, 500);
          },
          syncUI() {
            console.log("UI has been updated.");
          },
          updateAutosaveTime() {
            const now = new Date();
            this.autosaveTime =
              now.getFullYear() +
              "-" +
              (now.getMonth() + 1) +
              "-" +
              now.getDate() +
              " " +
              now.getHours() +
              ":" +
              now.getMinutes() +
              ":" +
              now.getSeconds();
          },
          generateUUID() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
              /[xy]/g,
              (c) => {
                const r = (Math.random() * 16) | 0;
                const v = c === "x" ? r : (r & 0x3) | 0x8;
                return v.toString(16);
              }
            );
          },
          addPlainBlock() {
            const id = this.generateUUID();
            this.blocks.push({ id, type: "plain", text: "Your narrative..." });
          },
          addStaticOptionBlock() {
            const id = this.generateUUID();
            this.blocks.push({ id, type: "static", options: [] });
          },
          addDynamicOptionBlock() {
            const id = this.generateUUID();
            this.blocks.push({
              id,
              type: "dynamic-option",
              blockName: "xxx",
              optionCount: 3,
              prompt: "",
              context: [],
            });
          },
          addDynamicTextBlock() {
            const id = this.generateUUID();
            this.blocks.push({
              id,
              type: "dynamic-text",
              blockName: "",
              sentenceCount: 1,
              prompt: "",
              context: [],
            });
          },
          addDynamicWordBlock() {
            const id = this.generateUUID();
            this.blocks.push({
              id,
              type: "dynamic-word",
              blockName: "",
              lexiconCategory: "noun",
              prompt: "",
              context: [],
            });
          },
          addSceneHeaderBlock() {
            const id = this.generateUUID();
            this.blocks.push({
              id,
              type: "scene-header",
              titleName: "",
              sceneId: null,
            });
          },
          removeBlock(index) {
            this.blocks.splice(index, 1);
          },
          moveBlockUp(index) {
            if (index > 0) {
              const movingBlock = this.blocks.splice(index, 1)[0];
              this.blocks.splice(index - 1, 0, movingBlock);
            }
          },
          moveBlockDown(index) {
            if (index < this.blocks.length - 1) {
              const movingBlock = this.blocks.splice(index, 1)[0];
              this.blocks.splice(index + 1, 0, movingBlock);
            }
          },
          addStaticOption(block) {
            block.options.push("");
          },
          removeStaticOption(block, index) {
            block.options.splice(index, 1);
          },
          addContext(block) {
            block.context.push({ value: "", includeAll: false });
          },
          removeContext(block, ctxIndex) {
            block.context.splice(ctxIndex, 1);
          },
          // Updated playStory() to use the parameterized endpoint based on the computed station.
          playStory() {
            this.updateSceneIds();
            // Use the computed station value
            const station = this.station;
            // TODO: parametrize server url
            fetch(`http://localhost:3001/save-story-json/${station}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ blocks: this.blocks }),
            })
              .then((res) => res.json())
              .then((data) => {
                if (data.success) {
                  // Open the corresponding station's page in a new window
                  // TODO: parametrize server url
                  window.open(`http://localhost:3001/${station}`, "_blank");
                } else {
                  console.error("Error saving story JSON:", data);
                }
              })
              .catch((err) => {
                console.error("Error saving story JSON:", err);
              });
          },
          exportJson() {
            this.updateAutosaveTime();
            this.updateSceneIds();
            const exportedBlocks = this.blocks.map((block) => {
              const baseBlock = {
                type: block.type,
                uuid: block.id,
                sceneId: block.sceneId,
              };

              if (block.type === "plain") {
                return { ...baseBlock, text: block.text };
              } else if (block.type === "static") {
                return { ...baseBlock, options: [...block.options] };
              } else if (block.type === "dynamic-option") {
                return {
                  ...baseBlock,
                  blockName: block.blockName,
                  optionCount: block.optionCount,
                  prompt: block.prompt,
                  context: JSON.parse(JSON.stringify(block.context)),
                };
              } else if (block.type === "dynamic-text") {
                return {
                  ...baseBlock,
                  blockName: block.blockName,
                  sentenceCount: block.sentenceCount,
                  prompt: block.prompt,
                  context: JSON.parse(JSON.stringify(block.context)),
                };
              } else if (block.type === "dynamic-word") {
                return {
                  ...baseBlock,
                  blockName: block.blockName,
                  lexiconCategory: block.lexiconCategory,
                  prompt: block.prompt,
                  context: JSON.parse(JSON.stringify(block.context)),
                };
              } else if (block.type === "scene-header") {
                return {
                  ...baseBlock,
                  titleName: block.titleName,
                };
              }
              return baseBlock;
            });

            const project = {
              autosave: this.autosaveTime,
              blocks: exportedBlocks,
            };

            const jsonString = JSON.stringify(project, null, 2);
            const blob = new Blob([jsonString], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "project_export.json";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          },
          importJson() {
            // Get the file input element
            const fileInput = document.getElementById("jsonFileInput");

            // Add an event listener for when a file is selected
            fileInput.onchange = (event) => {
              const file = event.target.files[0];
              if (!file) return;

              const reader = new FileReader();

              reader.onload = (e) => {
                try {
                  // Parse the JSON content
                  const projectData = JSON.parse(e.target.result);

                  // Check if the JSON has the expected structure
                  if (
                    !projectData.blocks ||
                    !Array.isArray(projectData.blocks)
                  ) {
                    alert(
                      'Error: Invalid project file format. The file must contain a "blocks" array.'
                    );
                    return;
                  }

                  // Confirm with the user before replacing the current project
                  if (this.blocks.length > 0) {
                    if (
                      !confirm(
                        "This will replace your current project. Continue?"
                      )
                    ) {
                      return;
                    }
                  }

                  // Process the imported blocks to ensure proper structure
                  const processedBlocks = projectData.blocks.map((block) => {
                    // Ensure ID field is consistent
                    const id = block.id || block.uuid || this.generateUUID();

                    // Create a properly structured block based on type
                    const baseBlock = {
                      id,
                      type: block.type,
                      sceneId: block.sceneId,
                    };

                    switch (block.type) {
                      case "plain":
                        return { ...baseBlock, text: block.text || "" };
                      case "static":
                        return {
                          ...baseBlock,
                          options: Array.isArray(block.options)
                            ? block.options
                            : [],
                        };
                      case "dynamic-option":
                        return {
                          ...baseBlock,
                          blockName: block.blockName || "",
                          optionCount: block.optionCount || 3,
                          prompt: block.prompt || "",
                          context: Array.isArray(block.context)
                            ? block.context
                            : [],
                        };
                      case "dynamic-text":
                        return {
                          ...baseBlock,
                          blockName: block.blockName || "",
                          sentenceCount: block.sentenceCount || 1,
                          prompt: block.prompt || "",
                          context: Array.isArray(block.context)
                            ? block.context
                            : [],
                        };
                      case "dynamic-word":
                        return {
                          ...baseBlock,
                          blockName: block.blockName || "",
                          lexiconCategory: block.lexiconCategory || "noun",
                          prompt: block.prompt || "",
                          context: Array.isArray(block.context)
                            ? block.context
                            : [],
                        };
                      case "scene-header":
                        return {
                          ...baseBlock,
                          titleName: block.titleName || "",
                        };
                      default:
                        return baseBlock;
                    }
                  });

                  // Update the project data
                  this.blocks = processedBlocks;
                  this.autosaveTime = projectData.autosave || "";
                  this.autoSaveProject();
                  // Display success message
                  alert("Project imported successfully!");
                } catch (error) {
                  console.error("Error importing project:", error);
                  alert(`Error importing project: ${error.message}`);
                }

                // Reset the file input
                fileInput.value = "";
              };

              reader.onerror = () => {
                alert("Error reading the file");
                fileInput.value = "";
              };

              // Read the file as text
              reader.readAsText(file);
            };

            // Trigger the file dialog
            fileInput.click();
          },
          // This function auto-saves the project to localStorage on every change.
          autoSaveProject() {
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;
            this.updateAutosaveTime();
            const project = {
              autosave: this.autosaveTime,
              blocks: this.blocks,
            };
            localStorage.setItem("vueRWSProject", JSON.stringify(project));
            console.log("Auto-saved to localStorage!");
            this.$nextTick(() => {
              window.scrollTo(scrollX, scrollY);
            });
          },
          // This function is triggered by the Save Project button and saves the project to a JSON file on the server.
          saveProject() {
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;
            this.updateAutosaveTime();
            const project = {
              autosave: this.autosaveTime,
              blocks: this.blocks,
            };
            fetch(`http://localhost:3001/save-story-json/${this.station}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(project),
            })
              .then((res) => res.json())
              .then((data) => {
                console.log("Project saved to server!", data);
              })
              .catch((err) => {
                console.error("Error saving project to server:", err);
              });
            this.$nextTick(() => {
              window.scrollTo(scrollX, scrollY);
            });
          },
          updateSceneIds() {
            let currentSceneId = 1;
            for (let i = 0; i < this.blocks.length; i++) {
              if (this.blocks[i].type === "scene-header") {
                this.blocks[i].sceneId = currentSceneId;
                currentSceneId++;
              } else {
                this.blocks[i].sceneId =
                  currentSceneId === 1 ? 1 : currentSceneId - 1;
              }
            }
          },
        },
        mounted() {
          // Auto-load project from localStorage
          const savedData = localStorage.getItem("vueRWSProject");
          if (savedData) {
            try {
              const parsedData = JSON.parse(savedData);
              this.autosaveTime = parsedData.autosave || "";
              this.blocks = parsedData.blocks || [];
            } catch (error) {
              console.error("Error parsing saved project", error);
            }
          }
          this.updateAutosaveTime();
        },
      });

      app.component("dynamic-block", {
        template: "#dynamic-block-template",
        props: ["block"],
        computed: {
          isOption() {
            return this.block.type === "dynamic-option";
          },
          isText() {
            return this.block.type === "dynamic-text";
          },
          isWord() {
            return this.block.type === "dynamic-word";
          },
          parentContextBlocks() {
            return this.$parent.contextBlocks;
          },
        },
        methods: {
          emitAddContext() {
            this.$emit("add-context", this.block);
          },
          emitRemoveContext(ctxIndex) {
            this.$emit("remove-context", this.block, ctxIndex);
          },
          getIndex(blockItem) {
            return this.$parent.blocks.indexOf(blockItem);
          },
        },
      });

      app.mount("#app");
    </script>
  </body>
</html>
