<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      http-equiv="Cache-Control"
      content="no-cache, no-store, must-revalidate"
    />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Story Player</title>
    <link rel="stylesheet" href="station1.css" />
    <script
      defer
      src="https://unpkg.com/alpinejs@3.11.1/dist/cdn.min.js"
    ></script>
  </head>
  <body>
    <div x-data="storyPlayer" x-init="init()">
      <div id="player-data"></div>

      <div id="passage-container">
        <!-- Passages will be rendered here -->
      </div>

      <div id="status-bar" x-text="'Story Player ID: ' + playerId"></div>
    </div>

    <script>
      document.addEventListener("alpine:init", () => {
        Alpine.data("storyPlayer", () => ({
          // Configuration
          serverUrl: window.location.origin.replace(/:\d+$/, ":3001"),
          playerId:
            "player_" +
            Date.now() +
            "_" +
            Math.random().toString(36).substring(2, 9),

          // State variables
          projectBlocks: [],
          passages: [],
          currentPassageIndex: 0,

          // Initialize the player
          init() {
            this.loadStory();
          },

          // Load story JSON
          loadStory() {
            fetch("input/story1.json?nocache=" + new Date().getTime())
              .then((response) => response.json())
              .then((data) => {
                if (data.blocks && Array.isArray(data.blocks)) {
                  this.projectBlocks = data.blocks;
                  this.groupBlocksIntoPassages();
                  this.renderPassage(0);

                  // Activate first passage
                  const firstPassage = document.getElementById("passage-0");
                  if (firstPassage) {
                    firstPassage.classList.add("active");
                    this.loadDynamicContentForPassage(firstPassage);
                  }
                } else {
                  document.getElementById("passage-container").innerHTML =
                    "<div class='error'>Error: Invalid story data</div>";
                }
              })
              .catch((error) => {
                console.error("Error loading story:", error);
                document.getElementById("passage-container").innerHTML =
                  "<div class='error'>Error loading story. Please make sure story1.json exists.</div>";
              });
          },

          // Group blocks into passages based on scene headers
          groupBlocksIntoPassages() {
            let current = [];
            this.passages = [];

            this.projectBlocks.forEach((block) => {
              if (block.type === "scene-header" && current.length > 0) {
                this.passages.push(current);
                current = [];
              }
              current.push(block);
            });

            if (current.length > 0) this.passages.push(current);
          },

          // Render a passage with its blocks
          renderPassage(passageIndex) {
            if (passageIndex >= this.passages.length) return;

            const container = document.getElementById("passage-container");
            const blocks = this.passages[passageIndex];
            const passageEl = document.createElement("div");

            passageEl.className = "passage";
            passageEl.id = "passage-" + passageIndex;

            // Create elements for each block
            blocks.forEach((block) => {
              const blockEl = document.createElement("div");
              blockEl.className = "block-" + block.type;
              blockEl.style.marginBottom = "20px";

              // Render different block types
              switch (block.type) {
                case "plain":
                  blockEl.innerHTML = `<div class="plain">${
                    block.text || ""
                  }</div>`;
                  break;

                case "static":
                  if (Array.isArray(block.options)) {
                    const optionsHTML = block.options
                      .map(
                        (opt, i) =>
                          `<div class="static-option" data-idx="${i}">${opt}</div>`
                      )
                      .join("");

                    blockEl.innerHTML = `<div class="static-option-container">${optionsHTML}</div>`;

                    // Add click handlers after rendering
                    setTimeout(() => {
                      const options =
                        blockEl.querySelectorAll(".static-option");
                      options.forEach((opt) => {
                        opt.addEventListener("click", () => {
                          this.selectOption(opt, block.id, "static");
                        });
                      });
                    }, 0);
                  }
                  break;

                case "dynamic-option":
                  blockEl.innerHTML = `
                  <div class="dynamic-container">
                    <div class="loading-indicator">Loading dynamic options... <span class="loading"></span></div>
                    <div class="dynamic-options-container" data-uuid="${block.id}"></div>
                  </div>`;
                  break;

                case "dynamic-text":
                  blockEl.innerHTML = `
                  <div class="dynamic-container">
                    <div class="loading-indicator">Generating text... <span class="loading"></span></div>
                    <div class="dynamic-text-container" data-uuid="${block.id}"></div>
                  </div>`;
                  break;

                case "dynamic-word":
                  blockEl.innerHTML = `
                  <div class="dynamic-container">
                    <div class="loading-indicator">Generating word... <span class="loading"></span></div>
                    <div class="dynamic-word-container" data-uuid="${block.id}"></div>
                  </div>`;
                  break;

                case "scene-header":
                  blockEl.innerHTML = `<h2>${block.titleName || "Scene"}</h2>`;
                  break;
              }

              passageEl.appendChild(blockEl);
            });

            // Add Continue link or End message
            if (passageIndex < this.passages.length - 1) {
              const link = document.createElement("div");
              const continueLink = document.createElement("a");
              continueLink.href = "#";
              continueLink.className = "next-link";
              continueLink.innerText = "Continue";
              continueLink.addEventListener("click", (e) => {
                e.preventDefault();
                this.goToNextPassage(passageIndex);
              });
              link.appendChild(continueLink);
              passageEl.appendChild(link);
            } else {
              const end = document.createElement("div");
              end.style.marginTop = "30px";
              end.style.textAlign = "center";
              end.style.fontStyle = "italic";
              end.innerText = "The End";
              passageEl.appendChild(end);
            }

            container.appendChild(passageEl);
          },

          // Load dynamic content for a passage
          loadDynamicContentForPassage(passageElement) {
            const dynamicContainers = passageElement.querySelectorAll(
              ".dynamic-options-container, .dynamic-text-container, .dynamic-word-container"
            );

            const promises = Array.from(dynamicContainers).map((container) => {
              let blockType = "";

              if (container.classList.contains("dynamic-options-container")) {
                blockType = "dynamic-option";
              } else if (
                container.classList.contains("dynamic-text-container")
              ) {
                blockType = "dynamic-text";
              } else if (
                container.classList.contains("dynamic-word-container")
              ) {
                blockType = "dynamic-word";
              }

              return this.fetchDynamicBlock(
                container.dataset.uuid,
                blockType,
                container
              );
            });

            return Promise.all(promises);
          },

          // Fetch dynamic content from server
          fetchDynamicBlock(blockID, blockType, container) {
            const blockData = this.projectBlocks.find((b) => b.id === blockID);

            if (!blockData) {
              container.innerText = "No block data found";
              return Promise.resolve();
            }

            const loadingIndicator = container
              .closest(".dynamic-container")
              .querySelector(".loading-indicator");

            return fetch(this.serverUrl + "/generate-dynamic", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                message: blockData.prompt || "",
                playerID: this.playerId,
                blockUUID: blockID,
                instruction: blockData.prompt || "",
                contextRefs: (blockData.context || []).filter(
                  (ctx) => ctx.value
                ),
                blockType,
              }),
            })
              .then((r) => r.json())
              .then((data) => {
                // Hide loading indicator
                if (loadingIndicator) loadingIndicator.style.display = "none";

                // Handle different dynamic content types
                if (blockType === "dynamic-option") {
                  const options = data.reply
                    .split("\n")
                    .filter((line) => line.trim() !== "");

                  const optionElements = [];

                  options.forEach((opt, i) => {
                    const optEl = document.createElement("div");
                    optEl.className = "static-option";
                    optEl.dataset.index = i;
                    optEl.textContent = opt;

                    // Add click event handler
                    optEl.addEventListener("click", () => {
                      this.selectOption(optEl, blockID, "dynamic-option");
                    });

                    optionElements.push(optEl);
                  });

                  // Clear and append new options
                  container.innerHTML = "";
                  optionElements.forEach((opt) => container.appendChild(opt));
                } else if (blockType === "dynamic-text") {
                  container.innerHTML = `<div class="dynamic-text-result">${
                    data.reply || ""
                  }</div>`;
                } else if (blockType === "dynamic-word") {
                  container.innerHTML = `<span class="dynamic-word">${
                    data.reply || ""
                  }</span>`;
                }
              })
              .catch((err) => {
                console.error("Error in fetchDynamicBlock:", err);
                container.innerText = "Error loading dynamic content.";
                if (loadingIndicator) loadingIndicator.style.display = "none";
              });
          },

          // Handle option selection (static or dynamic)
          selectOption(elem, blockID, type) {
            const container = elem.parentElement;
            const allOpts = container.querySelectorAll(".static-option");

            // Update UI
            allOpts.forEach((o) => {
              o.classList.add("faded");
              o.onclick = null; // Disable further clicks
            });

            elem.classList.remove("faded");
            elem.classList.add("selected");

            // Extract data
            const chosenText = elem.textContent;
            const chosenIndex =
              type === "static" ? parseInt(elem.dataset.idx) : undefined;

            // Record choice on server
            fetch(this.serverUrl + "/record-choice", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                playerID: this.playerId,
                blockUUID: blockID,
                blockType: type,
                chosenIndex: chosenIndex,
                chosenText,
                availableOptions: Array.from(allOpts).map((x) => x.textContent),
              }),
            });
          },

          // Navigate to next passage
          goToNextPassage(currIndex) {
            const currentEl = document.getElementById("passage-" + currIndex);
            const nextIndex = currIndex + 1;

            // Render next passage if it doesn't exist yet
            if (!document.getElementById("passage-" + nextIndex)) {
              this.renderPassage(nextIndex);
            }

            const nextEl = document.getElementById("passage-" + nextIndex);
            nextEl.style.display = "none";

            // Start fade-out animation on current passage
            if (currentEl) {
              currentEl.classList.add("fade-out");
            }

            // Load dynamic content and handle transition
            this.loadDynamicContentForPassage(nextEl).then(() => {
              // Complete fade-out of current passage
              if (currentEl) {
                const handleTransitionEnd = () => {
                  currentEl.classList.remove("active", "fade-out");
                  currentEl.style.display = "none";
                  currentEl.removeEventListener(
                    "transitionend",
                    handleTransitionEnd
                  );
                };

                currentEl.addEventListener(
                  "transitionend",
                  handleTransitionEnd,
                  { once: true }
                );
              }

              // Show and fade-in next passage
              nextEl.style.display = "";
              nextEl.classList.add("active", "fade-in");
              this.currentPassageIndex = nextIndex;
              window.scrollTo(0, 0);

              // Remove animation class when complete
              nextEl.addEventListener("animationend", function handler() {
                nextEl.classList.remove("fade-in");
                nextEl.removeEventListener("animationend", handler);
              });
            });
          },
        }));
      });
    </script>
  </body>
</html>
